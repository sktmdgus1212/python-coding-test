A. 서로소 집합
공통 원소가 없는 두 집합

1. 합집합(union) 
노드 번호와 부모 노트를 함께 작성하여 집합을 합쳐줌
 
2. 찾기(find)
루트 노드를 찾기 위해 부모 테이블을 계속해서 올라가야함
합집합 연산이 편향되게 이루어지는 경우 찾기 함수가 비율적으로 동작
    -> 시간 복잡도 O(V)
    -> 경로 압축 필요!
    -> 찾기 함수를 재귀적으로 호출한 후 부모 테이블 값을 바로 갱신

- 서로소 집합을 활용한 사이클 판별
무방향 그래프 내에서 사이클 판별
(1) 각 간선을 하나씩 확인하면 두 노드의 루트 노드를 확인
    (1-1) 루트 노드가 서로 다르다면 두 노드에 대해 합집합 연산 수행
    (1-2) 루트 노드가 서로 같다면 사이클 발생
(2) 모든 간선에 대해 1번 과정 반복


B. 클루스칼 알고리즘 
- 신장 트리
그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프(트리의 조건)

- 최소 신장 트리
최소한의 비용으로 구성되는 신장 트리를 찾아야 할 때
임의의 두 노드를 선택했을 때 경로가 무조건 존재해야함

- 크루스칼 알고리즘
최소 신장 트리 알고리즘
(1) 간선 데이터를 비용에 따라 오름차순으로 정렬
(2) 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
    (2-1) 사이클이 발생하지 않는 경우 최소 신장 트리에 포함
    (2-2) 사이클이 발생하는 경우 최소 신장 트리에 포함 X
(3) 모든 간선에 대해 (2)번 과정 반복
최소 신장 트리 간선 개수는 (노드-1)개
-> O(ElogE)의 시간 복잡도를 가짐(간선 개수: E)


C. 위상 정렬
사이클이 없는 방향 그래프(DAG)의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열
(EX. 선수과목을 고려한 학습 순서 결정)
여러 개의 답이 존재할 수 있음(한 단게에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우)
모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단
큐, 스택을 활용한 위상 정렬 표현 가능
 ㅡ
진입차수(Indegree): 특정 노드로 들어오는 간선 개수
진출차수(Outdegree): 특정 노드에서 나가는 간선 개수

- 큐를 이용하는 위상정렬
(1) 진입차수가 0인 모든 노드를 큐에 삽입
(2) 큐가 빌 때까지 다음 과정 반복
    (2-1) 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거
    (2-2) 새롭게 진입차수가 0이 된 노드를 큐에 삽입
-> 각 노드가 큐에 들어온 순서가 위상 정렬 수행한 결과와 동일

O(V+E)의 시간 복잡도를 가짐